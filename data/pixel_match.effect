layout (binding = 0, offset = 0) uniform atomic_uint compare_counter;
layout (binding = 1, offset = 0) uniform atomic_uint match_counter;

uniform texture2d image;
uniform float4x4 ViewProj;

uniform texture2d match_img;
uniform float per_pixel_err_thresh;
uniform float roi_left;
uniform float roi_bottom;
uniform float roi_right;
uniform float roi_top;

uniform bool debug;
uniform float border_width;
uniform float border_height;

sampler_state def_sampler {
    Filter   = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
};

struct VertInOut {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

float4 PSMatch(VertInOut vert_in) : TARGET
{
    float4 val = image.Sample(def_sampler, vert_in.uv);
    float u = vert_in.uv.x, v = vert_in.uv.y;
    bool hbound = (u >= roi_left && u <= roi_right);
    bool vbound = (v >= roi_bottom && v <= roi_top);

    if (!hbound || !vbound)
        return val;

    float2 sample_uv = (vert_in.uv - float2(roi_left, roi_bottom))
        / float2(roi_right - roi_left, roi_top - roi_bottom);
    float4 cmp = match_img.Sample(def_sampler, sample_uv);
    bool cmp_on = cmp.r > 0.05 || cmp.g > 0.05 || cmp.b > 0.05;
    if (cmp_on) {
        atomicCounterIncrement(compare_counter);
    }

    bool match_on = cmp_on && val.r > 0.05 && val.g > 0.05 && val.b > 0.05;
    if (match_on) {
        atomicCounterIncrement(match_counter);
    }

    if (debug) {
        if (vbound
          && (abs(u - roi_left) < border_width
           || abs(u - roi_right) < border_width)) {
            // show white border for the ROI region
            val = float4(1, 1, 1, 1);
        } else if (hbound
                 && (abs(v - roi_bottom) < border_height
                  || abs(v - roi_top) < border_height)) {
            // show white border for the ROI region
            val = float4(1, 1, 1, 1);
        } else if (cmp_on) {
            // show green or red, depending on a match/no match
            val = match_on ? float4(0, 1, 0, 1) : float4(1, 0, 0, 1);
        }
        // else: compare off, no border -> keep the passthrough value
    }

    return val;
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(vert_in);
        pixel_shader = PSMatch(vert_in);
    }
}
