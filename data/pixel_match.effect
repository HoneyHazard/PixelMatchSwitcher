layout (binding = 0) uniform atomic_uint compare_counter;
layout (binding = 1) uniform atomic_uint match_counter;

uniform texture2d image;
uniform float4x4 ViewProj;

uniform texture2d match_img;
uniform float3 mask_color;
uniform bool mask_alpha;
uniform float per_pixel_err_thresh;
uniform float roi_left;
uniform float roi_bottom;
uniform float roi_right;
uniform float roi_top;

uniform bool visualize;
uniform float px_width;
uniform float px_height;

sampler_state def_sampler {
    Filter   = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
};

struct VertInOut {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

float match_ratio(float3 val, float3 expect)
{
    float3 diff = abs(val - expect);
    return (diff.x + diff.y + diff.z) / 3.0;
}

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

float4 PSMatch(VertInOut vert_in) : TARGET
{
    float2 uv = vert_in.uv;
    if (visualize) {
        uv += float2(px_width, px_height)/2;
    }
    float u = uv.x, v = uv.y;

    float4 val = image.Sample(def_sampler, uv);
    bool hbound = (u >= roi_left && u <= roi_right);
    bool vbound = (v >= roi_bottom && v <= roi_top);

    if (!hbound || !vbound)
        return val;

    float2 sample_uv = (uv - float2(roi_left, roi_bottom))
        / float2(roi_right - roi_left, roi_top - roi_bottom);
    float4 cmp_val = match_img.Sample(def_sampler, sample_uv);
    //bool cmp_on = cmp.r > 0.05 || cmp.g > 0.05 || cmp.b > 0.05;
    bool cmp_on;
    if (mask_alpha) {
        cmp_on = (cmp_val.a > 0);
    } else {
        cmp_on = (cmp_val.xyz != mask_color);
    }

    if (cmp_on) {
        atomicCounterIncrement(compare_counter);
    }

    //bool match_on = cmp_on && val.r > 0.05 && val.g > 0.05 && val.b > 0.05;
    bool match_on
        = (cmp_on && match_ratio(val.xyz, cmp_val.xyz) <= per_pixel_err_thresh);
    if (match_on) {
        atomicCounterIncrement(match_counter);
    }

    if (visualize) {
        float border_width = px_width * 2.0, border_height = px_height * 2.0;
        if (vbound
          && (abs(u - roi_left) < border_width
           || abs(u - roi_right) < border_width)) {
            // show inverted border for the ROI region
            val = float4(float3(1) - val.xyz, 1.0);
        } else if (hbound
                 && (abs(v - roi_bottom) < border_height
                  || abs(v - roi_top) < border_height)) {
            // show inverted border for the ROI region
            val = float4(float3(1) - val.xyz, 1.0);
        } else if (cmp_on) {
            // show green or red hues, depending on a match/no match
            float intensity = 0.3 + (val.r + val.g + val.b) / 3.0 * 0.7;
            val = match_on ? float4(0, intensity, 0, 1)
                           : float4(intensity, 0, 0, 1);
        }
        // else: compare off, no border -> keep the passthrough value
    }

    return val;
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(vert_in);
        pixel_shader = PSMatch(vert_in);
    }
}
